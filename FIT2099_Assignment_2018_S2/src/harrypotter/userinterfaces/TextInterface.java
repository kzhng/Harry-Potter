/**
 * A text-based UI for displaying messages and the simulation grid, and for obtaining user input.
 * 
 * At some stage we might want to replace this UI with a GUI.
 * 
 * @author ram
 * @author Asel
 */
/*
 * Change log
 * 2017-02-02: Displaying the map/grid is now a responsibility of the TextInterface and not of Grid or MiddleWorld (asel)
 * 2017-02-04: Removed the HPGrid parameter from the displayTextGrid method and renamed it to drawGrid() - (asel)
 */
package harrypotter.userinterfaces;


import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

import edu.monash.fit2099.simulator.matter.EntityManager;
import edu.monash.fit2099.simulator.userInterface.MapRenderer;
import edu.monash.fit2099.simulator.userInterface.MessageRenderer;
import edu.monash.fit2099.simulator.userInterface.SimulationController;
import harrypotter.HPActionInterface;
import harrypotter.HPActor;
import harrypotter.HPEntityInterface;
import harrypotter.HPGrid;
import harrypotter.HPLocation;
import harrypotter.HPWorld;

/**
 * IMPORTANT
 * This UI is no longer required and is not compatible with the controller. Needs to be deleted! - Asel
 */
public class TextInterface implements MessageRenderer, MapRenderer, SimulationController {
	
	/** Hobbit grid of the world*/
	private HPGrid grid;
	
	/** The number of items to be displayed per location including the location label and colon ':'*/
	private static int locationWidth = 8;

	/**
	 * Constructor for the Text Interface
	 * <p>
	 * This text interface can be used to display messages, grid and obtain user input in the Text Console
	 * 
	 * @author 	ram
	 * @param 	world The world being considered by the Text Interface
	 * @pre 	world should not be null
	 */
	public TextInterface(HPWorld world) {
		grid = world.getGrid();
	}

	/**
	 * Display the simulation banner.
	 * 
	 * Based on code from the original Eiffel version of this program, and originally 
	 * generated by the UNIX program figlet.
	 * 
	 * @author ram
	 */
	public static void showBanner() {
		String [] lines = { 
			" _   _                         ____       _   _            ",
			"| | | | __ _ _ __ _ __ _   _  |  _ \\ ___ | |_| |_ ___ _ __ ",
			"| |_| |/ _` | '__| '__| | | | | |_) / _ \\| __| __/ _ \\ '__|",
			"|  _  | (_| | |  | |  | |_| | |  __/ (_) | |_| ||  __/ |   ",
			"|_| |_|\\__,_|_|  |_|   \\__, | |_|   \\___/ \\__|\\__\\___|_|   ",
			"                       |___/                               ",
		};
		
		for(String line: lines) {
			System.out.println(line);
			System.out.println();
		}
	}
		
			
			
	

	
	/**
	 * Render the grid and display it in the Text Interface
	 * 
	 * @author ram
	 * @author Asel
	 */
	@Override
	public void render() {
		drawGrid();	
	}

	
	/**
	 * Display a message.  Part of the MessageRenderer interface.
	 * 
	 * @author ram
	 * @param message the String to display
	 */
	@Override
	public void render(String message) {
		System.out.println(message);

	}

	/**
	 * Displays the Hobbit Grid using a System.out.println()
	 * <p>
	 * This method prints the entire Hobbit Grid as a text output. 
	 * Each location will be separated out with vertical seperators '|' and will contain the symbols 
	 * of the locations contents
	 * 
	 * @author 	Asel
	 * @post 	prints the Grid (a matrix of locations with there contents) on the console as text
	 * 
	 */
	private void drawGrid(){
		
		assert (grid!=null)	:"grid to be draw cannot be null";
		
		String buffer = "";
		final int gridHeight = grid.getHeight();
		final int gridWidth  = grid.getWidth();
		
		EntityManager<HPEntityInterface, HPLocation> em = HPWorld.getEntitymanager();
		
	
		for (int row = 0; row< gridHeight; row++){ //for each row
			for (int col = 0; col< gridWidth; col++){ //each column of a row
				
				//current location
				HPLocation loc = grid.getLocationByCoordinates(col, row);
				
				StringBuffer emptyBuffer = new StringBuffer();
				char es = loc.getEmptySymbol(); 
				
				for (int i = 0; i < locationWidth - 3; i++) { 	//add empty symbol character to the buffer
					emptyBuffer.append(es);						//adding 2 less here because one space is reserved for the location symbol
				}									  			//and one more for the colon : used to separate the location symbol and the symbol(s) of the contents of that location
					
				//new buffer buf with a vertical line separator | + symbol of the location + :
				StringBuffer buf = new StringBuffer("|" + loc.getSymbol() + ":"); 
				
				//get the Contents of the location
				List<HPEntityInterface> contents = em.contents(loc);
				
				
				if (contents == null || contents.isEmpty())
					buf.append(emptyBuffer);//add empty buffer to buf to complete the string buffer
				else {
					for (HPEntityInterface e: contents) { //add the symbols of the contents
						buf.append(e.getSymbol());
					}
				}
				buf.append(emptyBuffer); //add the empty buffer again since the symbols of the contents that were added might not actually fill the location upto locationWidth
				
				buf.setLength(locationWidth+1);//set the length of buf to the required locationWidth
				
				buf.append("| ");//add the vertical line seperator to mark the end of that location
				
				buffer += buf; //add the buffer (buf) created for the location to the buffer (the buffer that will eventually be printed)
				
			}
			buffer += "\n"; //new row
		}
		
		System.out.println(buffer); //print the grid on the screen
	}
	
	/**
	 * Display a menu and receive user input.
	 * 
	 * @param a the HPActor to display options for
	 * @return the HPActionInterface that the player has chosen to perform.
	 */
	public static HPActionInterface getUserDecision(HPActor a) {
		Scanner instream = new Scanner(System.in);
		ArrayList<HPActionInterface> cmds = new ArrayList<HPActionInterface>();

		//for all the actions of the Hobbit actor
		for (HPActionInterface ac : HPWorld.getEntitymanager().getActionsFor(a)) {
			if (ac.canDo(a))
				cmds.add(ac);//add the ones the Hobbit Actor can do
		}
		
		Collections.sort(cmds);//sorting the actions for a prettier output

		//construct the commands to be displayed on screen
		for (int i = 0; i < cmds.size(); i++) {
			System.out.println(i + 1 + " " + cmds.get(i).getDescription());
		}

		
		int selection = 0;
		while (selection < 1 || selection > cmds.size()) {//loop until a command in the valid range has been obtained
			System.out.println("Enter command:");
			selection = (instream.nextInt());
		}

	
		return cmds.get(selection-1);//return the action selected
	}
}
